# Communication between modules

This is I believe a topic that is not so well documented[^communication-between-modules-1], but not so different from previous chapters.

[^communication-between-modules-1]: There is a good introduction article in the Shiny documentation [@positShinyCommunication], but it relies on the `callModule` function while it's help page suggests to use `moduleServer`.

In my experience, every time you face a communication problem between your modules, the use case is out of the *'getting started with'* examples, which ends up in hours of online searches (assuming you're trying to understand the different options to make a wise choice - not asking a LLM).

The purpose of this chapter is mostly to go through the two patterns that may be used in a complex app and demonstrate that it's not different from what we saw previously.

Remember the main server / module server communication is basically parent / child communication.\
Same applies to communication between modules.

## Nested modules

As mentioned earlier, there are specific use cases when a module would call another module.\
The typical use case for this implementation is when you want to delegate some task from the module to a sub module because your module server itself is growing and requires some architecture. Another great example is when a specific task / feature is not always needed. Maybe something not all users will be allowed to use or require. In this case it's good practice to avoid the creation of reactives and observers if they will never be reached[^communication-between-modules-2].

[^communication-between-modules-2]: Input entries are created only when their ui is implemented.

Maybe the term *nested* is not the best because it creates some confusion over the simple main server / module server pattern. It somehow feels like it's going to be different and many (including myself) starts their journey into the module world with a biased interpretation in mind.

Well basically a *nested* module is in fact a **child** of a parent module, so that it is the same as having the main server as parent and a module as a child!

The only thing is that now, you need to think the communication as a two-step process.\
Remember that everything is a child of something and runs into its own context.

::: callout-important
One key best practice here is that data / information *should*[^communication-between-modules-3] go through all levels of the architecture from the source level to the target level otherwise you will break the **mindset** of the architecture.
:::

[^communication-between-modules-3]: 'Should' because technically the main server could listen to a nested module's input with the correct namespace.

Another good reason why to pass on information along the hierarchy is that it is then possible to alter this information before passing it to the next level.\
Imagine a data.frame that is passed to a module from the main server, maybe a sub/nested module only requires a specific columns to compute a value or a plot.

### Inputs

Again, everything here will work exactly like we saw in the previous chapters.\
The goal here is to observe and understand the mechanism so that it will help demystify it when it comes to creating your own architecture.

::: callout-tip
The [module-nested-input](https://github.com/thekangaroofactory/template-r-shiny-communication/tree/main/module-nested-input) folder of the GitHub repository linked to this book implements a basic use case of a server / module / nested module implementation to support this section.
:::

In this example, the main app server calls a module server function in which the sub / nested module server is itself called.

![Nested module architecture](image/nested-module-architecture.png)

The sub module has a `sub_module_ui` function which defines a text input:

```{r}
#| eval: false

sub_module_UI <- function(id) {

  # -- declare input
  textInput(inputId = NS(id, "text"),
            label = "Sub module server input",
            value = "")

}

```

The key notion to understand here is that as long as you pass the *'correct'* `id` value to the function, it could be used at any level (typically the main server) to implement the input. But as long as you made a choice to implement a sub module level, you should stick to only create parent-child **dependencies**.

This means the sub module ui function should always be called from its parent - no matter if the parent is the main server or another module (this is what encapsulation actually means).

```{r}
#| eval: false

module_UI <- function(id) {

  # -- return
  tagList(

    # -- module input
    numericInput(inputId = NS(id, "numeric"),
                 label = "Module server input",
                 value = 0),

    # -- sub module ui
    sub_module_UI(NS(id, "submodule")))

}

```

To ensure this encapsulation principle, the `sub_module_UI` function is called from the `module_UI` function. In most cases, you will add more content together with the ui coming from the sub module - here we add a numeric input - but you may also just create a wrapper function around the sub module ui function.

::: callout-tip
Have you ever played around with the `NS()` function?

Notice how we keep using `NS(id, "some_inputId")` at each module level.\
Calling `module_UI(id = "module")` will then call `sub_module_UI(NS(id, "submodule"))` that in turn calls `textInput(inputId = NS(id, "text"), ...)`

Well this is just like calling `NS(NS("module", "submodule"), "text")` which ends up in

> "module-submodule-text"

In fact, `NS` even accepts vectors like `NS(c("foo", "bar"), "zoo")` but I don't see any use case except if you break the encapsulation (which in turn is not a valid use case).
:::

The resulting UI architecture looks like this:

![Nested module UI](image/nested-module-ui.png)

You may ask yourself why I put the modules ui functions inside dotted boxes.\
Well, they are not *really* executed like that nor at different levels since they are only called from the main app ui as a chain[^communication-between-modules-4]! Only the namespace assignment makes their input visible to a certain module / level in the architecture. This ensures that a given module can be used at any level of the hierarchy (we could imagine of a module being used in different branch at different levels for example).

[^communication-between-modules-4]: So it's more main app ui \> module ui \> sub module ui

All of the three servers have a listener that prints the `names` of the input list:

> Listening on http://127.0.0.1:7393\
> Input(s) seen by the sub-module server: text\
> Sub-module input =\
> Input(s) seen by the module server: numeric / submodule-text\
> Module input = 0\
> Input(s) seen by the main server: module-numeric / module-submodule-text

See how everything is really a matter of context / scope and parent-child relationship!\
Basically, if you say zoom on the module and sub module levels, you get exactly the same result as the one we saw in the module communication chapters.

When building an architecture for your apps, it's key to keep in mind how the information flow goes through the different layers (and between the ui / server sides):

![Nested module input communication process](image/nested-module-input-communication.png)

While the ui representation of an input goes up through the ui functions, its value on server side goes down from a level to the next one and is directly[^communication-between-modules-5] accessible at the right level thanks to the namespace mechanism.

[^communication-between-modules-5]: By *directly*, I mean through an `input$foo` instruction

### Outputs

Here we will just implement same basic example as for the module communication to see how things go.\
Remember that outputs are meant to communicate / render information from the server side to the ui side up to the main app level (what the users see).

::: callout-tip
The [module-nested-output](https://github.com/thekangaroofactory/template-r-shiny-communication/tree/main/module-nested-output) folder of the GitHub repository linked to this book implements a basic use case of a server / module / nested module implementation to support this section.
:::

Basically it has the same architecture as the previous section's example except all three servers (main, module & sub-module) focus on the outputs.

They implement a simple text output[^communication-between-modules-6] :

[^communication-between-modules-6]: Note that in real life, this `renderText` would involve some dynamic content (or be on ui side)

```{r}
#| eval: false

output$text <- renderText("This is a sample text from the main server")

```

And use the same approach as for the module communication to explore the visible outputs:

```{r}
#| eval: false

outs <- outputOptions(output)
cat("Outputs seen from the main server: ", paste(names(outs), collapse = " / ", "\n"))

```

The output from the sub-module server is rendered inside the `sub_module_UI` function while the one from the module server is rendered in the `module_UI` function along with a call to the sub-module ui function[^communication-between-modules-7].

[^communication-between-modules-7]: Same approach as for the inputs

When launching the app, the console will display this:

> Listening on <http://127.0.0.1:7393>\
> Outputs seen from the submodule server: module-submodule-text\
> Outputs seen from the module server: module-submodule-text / module-text\
> Outputs seen from the main server: module-submodule-text / module-text / text

::: callout-note
Notice how the module and sub-module servers only see the outputs from their own scope but still see them with their names wrapped into the namespace[^communication-between-modules-8].
:::

[^communication-between-modules-8]: That's because you can't read outputs unless you pass them to \*output functions (here `textOutput`)

Let's recap all this in a communication schema:

![Nested module output communication](image/nested-module-output-communication.png)

Outputs are defined on the server side, then consumed on the ui side **at the same level**, then go up through the ui functions just as the inputs did[^communication-between-modules-9].

[^communication-between-modules-9]: Because they are basically HTML at this stage

There is no backward communication since outputs are just meant to display content into the browser.

### Parameters

As we saw earlier, parameters are used in a quite standard way when it comes to module server functions and having nested modules is no exception to that.

::: callout-tip
The [module-nested-parameter](https://github.com/thekangaroofactory/template-r-shiny-communication/tree/main/module-nested-parameter) folder of the GitHub repository linked to this book implements the use case of a server / module / nested module implementation to support this section.
:::

The idea here is to observe how an input value can be passed on from the main server (main app level) to the sub-module. In order to make thinks a bit more realistic[^communication-between-modules-10], the input value will be altered as the module server level.

[^communication-between-modules-10]: Use-cases are voluntarily very simple to avoid mixing notions as they are meant to support a specific section of the book.

This time the main app is just composed of a `numericInput` on ui side, and the server is listening to its value:

```{r}
#| eval: false

function(input, output, session) {

  # -- declare reactive (to pass on to the module)
  foo <- reactive({
    cat("Server input update / value =", input$numeric, "\n")
    input$numeric})

  # -- launch module server
  module_server(id = "module", trigger = foo)

}

```

We could just set `trigger = reactive(input$numeric)` but the intermediate `foo` reactive helps showing that we actually pass the reference of the reactive (i.e. not its value) to the function parameter.

The module server listens to this reactive just like it did in the module communication chapter except this time we will wrap the dependency into a `reactive`[^communication-between-modules-11] as well:

[^communication-between-modules-11]: Indeed, we need a reactive component that returns a value!

```{r}
#| eval: false

module_server <- function(id, trigger) {
  moduleServer(id, function(input, output, session) {

    # -- check parameter
    stopifnot(is.reactive(trigger))

    # -- listen to the trigger & create a reactive
    bar <- reactive({
      cat("Module parameter update / value =", trigger(), "\n")
      trigger() * 2})

    # -- call nested module
    sub_module_server(id = "submodule", trigger = bar)

  })
}

```

The sub-module server only observes its reactive parameter (reinforcing the idea that it could be used in any kind of component as long as you take a dependency on its value):

```{r}
#| eval: false

observeEvent(trigger(),
             cat("Sub-module parameter update / value =", trigger(), "\n"))

```

At launching, the console will display the initial trace (the input is valuated with 0 at start-up). Here the user has clicked once on the `numericInput` increment arrow:

> Listening on <http://127.0.0.1:3270> \
> Server input update / value = 0 \
> Module parameter update / value = 0 \
> Sub-module parameter update / value = 0 \
> Server input update / value = 1 \
> Module parameter update / value = 1 \
> Sub-module parameter update / value = 2

As expected the value is passed from the main server to the module server.\
It is then altered and passed on to the sub-module server.

::: callout-note
Note that we chose to pass on the input value defined at the main level, but we could pass any kind of data.
:::

The resulting communication schema is as follows:

![Nested module parameter communication](image/nested-module-parameter-communication.png)

The important takeaway here is that the key to launch specific tasks inside a module is to pass a reactive **reference** as a parameter and take dependency on it inside the module.

### Return value(s)

## Siblings modules

explain that this in fact does not exist.

siblings = child - parent - child so we are back to the parent - child relationship

provide an example

Siblings modules\
It's very common to implement modules at the same level, in particular as children of the main server.\
main \> module 1 \| module 2

We've seen how to communication from main to server 1 or server 2 and back but how to communication from server 1 to server 2?\
Check options:

```         
through the parent (param / return value + transformation) directly through the reactive references (still need to pass them via the parent) 
```

Again it's recommended to implement proxy return values to avoid altering the data itself.
